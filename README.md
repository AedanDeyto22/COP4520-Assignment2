# COP4520-Assignment2

## Problem 1 Summary
I based my solution off of the prisoner light switch solution from chapter 1. Where the guest choose 1 person as the counter and the person to tell the minotaur that everyone has visted the labyrinth. When a guest enters the labyrinth they have a choice to eat a cupcake at the end or leave it. So when a guest (not the counter) enters, if they haven't eaten the cupake then they will if the cupcake in on the plate and any other situation they will just return. When the counter enters they will look to see if the plate is empty, if it is they will increment their count and repalce the eaten cupcake and if not they will do nothing and  just return. If the counter's count is equal to the amount of guest at the party then they will notify the minotaur.

So all the threads are not interacting with each other and only to the minotaur, the main class. So the minotaur will keep running until its notifyed by the counter. The threads will keep running until they see that the minotaur has stopped letting the guest into the labyrinth. So each of the threads will wait until they are allowed by the minotaur to enter the labyrinth, in which they will enter the labyrinth and perform thier nessary actions. After performing thier actions they will notify the minotaur that they can choose another person to enter the labyrinth. The way the minotaur knows when cna it choose another guest and when all the guest have entered is by a volatile boolean flag. This flag can updated by the threads and since its volatile the program knows it will be constanly changing and will always have the most udpated  version.

## Problem 2 Summary
When it came to problem 2 the solution I choose to go with was solution 3 using queues. My reasoing for this was becuase of the issue with solution 1 and solution 2, since both would not guurantee when and if the user would be able to go into the showroom. With solution 1 and 2 being similar in that the guests will wait until they see an indicator that they can go in, but they will be unable to guarantee that they can see the showrrom. Solution 3 guarantee that a guest will be allowed to enter the show room. Since when the guest queues in to enter the room that means sooner or later they will be let in. 

When implmenting startegy 3, I used an MCS queue lock and based my code on the code given in the book. So when creating all the threads the threads are given an atomic refernce to the tail of the queue and each of the threads have their own local node hat will be their node when they enter the queue. So the threads will flip a coin to choose if they would want to enter the queue. When they try to enter the queue they get thier local node and the adress of the tail, they will first add thier node to the tail of the queue and then see if anyone is ahead of them. If there is no one then they can just enert the showroom, if there is somone then they will set the next address of the node infront of them to them and wait until they can enter. After a thread is done in the showroom, they will have to notify the next thread after them they do this first checking if there is anyone after them if not they wait to see if anyone is trying to queue in if so then wait, if not then just return and that means the everyone done looking at the vase. When they tell the next thread ot enter they go to it and flag them that they can enter the show room then they set thier next to null show they exited the queue.
