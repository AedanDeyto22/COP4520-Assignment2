# COP4520-Assignment2

## Problem 1 Summary
I based my solution off of the prisoner light switch solution from chapter 1. Where the guest choose 1 person as the counter and the person to tell the minotaur that everyone has visted the labyrinth. When a guest enters the labyrinth they have a choice to eat a cupcake at the end or leave it. So when a guest (not the counter) enters, if they haven't eaten the cupake then they will if the cupcake in on the plate and any other situation they will just return. When the counter enters they will look to see if the plate is empty, if it is they will increment their count and repalce the eaten cupcake and if not they will do nothing and  just return. If the counter's count is equal to the amount of guest at the party then they will notify the minotaur.

So all the threads are not interacting with each other and only to the minotaur, the main class. So the minotaur will keep running until its notifyed by the counter. The threads will keep running until they see that the minotaur has stopped letting the guest into the labyrinth. So each of the threads will wait until they are allowed by the minotaur to enter the labyrinth, in which they will enter the labyrinth and perform thier nessary actions. After performing thier actions they will notify the minotaur that they can choose another person to enter the labyrinth. The way the minotaur knows when cna it choose another guest and when all the guest have entered is by a volatile boolean flag. This flag can updated by the threads and since its volatile the program knows it will be constanly changing and will always have the most udpated  version.

## Problem 2 Summary
When it came to problem 2 the solution I choose to go with was solution 3 using queues. My reasoing for this was becuase of the issue with solution 1 and solution 2, since both would not guurantee when and if the user would be able to go into the showroom. With solution 1 and 2 being similar in that the guests will wait until they see an indicator that they can go in, but they will be unable to guarantee that they can see the showrrom. Solution 3 guarantee that a guest will be allowed to enter the show room. Since when the guest queues in to enter the room that means sooner or later they will be let in. Both solution 1 and 2 have their advantage as in they can enter the room whenever they can if available. So if the threads see they can enter the showroom they try to, so compared to solution 3 the threads will have to wait for their turn while solution 1 and 2 allows the threads to try to enter whenever it can. However, this does lead to the issue I said earlier with that threads not guaranteed to be able to enter the showroom, while solution 3 does when the threads enters the queue they know they will be given access sooner or later.

When implmenting startegy 3, I used an MCS queue lock and based my code on the code given in the book. So when creating all the threads the threads are given an atomic refernce to the tail of the queue and each of the threads have their own local node hat will be their node when they enter the queue. So the threads will flip a coin to choose if they would want to enter the queue. When they try to enter the queue they get thier local node and the adress of the tail, they will first add thier node to the tail of the queue and then see if anyone is ahead of them. If there is no one then they can just enert the showroom, if there is somone then they will set the next address of the node infront of them to them and wait until they can enter. After a thread is done in the showroom, they will have to notify the next thread after them they do this first checking if there is anyone after them if not they wait to see if anyone is trying to queue in if so then wait, if not then just return and that means the everyone done looking at the vase. When they tell the next thread ot enter they go to it and flag them that they can enter the show room then they set thier next to null show they exited the queue. MCS queue locsk makes queue in and notiyfing the enxt in line fairly quick. Since it the procces of queueing in is just a runtime of O(1) sicne its primarly getting and setting values, when a thread is waiting to get access is the longest of quueing in. The same when it comes to notifying the next user, it's just getting and updating values and it might wait for a slow thread to queue in. So both the process of queuing in and notifying the next user is O(1). So the majority of the runtime would be based on how long the thread takes inside the showroom. 

## Testing Both Problem 1 & 2
When it comes to testing I have found for problem 1 the bigger threads it has the longer it takes and the more times a guest enters the labyrinth. For 10 guests it took 2 seconds with 158 entries, for 20 it took 22 seconds with 392 entries, and for 50 guests I have found that it took 68 seconds for 2268 entries. I even tested with 100 guests, and found that it took about 8 ish minutes and about 9000ish entries into the labyrinth to finish.  For the 50 and 100 guests I did my testing on eustis since my machine couldnâ€™t handle running that many threads at once. 

When it comes to testing for problem 2 I have found that Thread.sleep() to be a big issue when it comes to my threads runtime. So when a thread enters the showroom it sleeps for about 10 milliseconds to simulate that it's looking at the vase and then will exit the showroom to notify the next guest in the queue. All the guests can requeue up to 3 times. So after testing I have found that with Thread.sleep running 100 threads it took 157 seconds to finish, while without it took about 67 milliseconds to run. Thus, I have chosen to not include Thread.sleep() in my code to get the fastest runtime but I just commented it out and you are allowed to uncomment it if you would like to simulate the guest being in the showroom.

